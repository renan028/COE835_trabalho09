\section{Implementação}

Para a implementação, só é preciso computar os filtros:
%
\begin{align}
\dot{\lambda} &= A_0\lambda + e_2u \\
\dot{\eta} &= A_0\eta + e_2y
\end{align}

É possível demonstrar que:
%
\begin{align}
\Xi &= -\left[A_0\eta \quad \eta \right] \\
\xi &= -A_0^2\eta \\
v_0 &= \lambda
\end{align} 

Temos ainda que $\alpha =
\hat{\rho}(-c_1z_1-d_1z_1-\xi_2-\bar{\omega}^\intercal\hat{\theta})$. Logo:
%
\begin{align}
\frac{\partial \alpha_1}{\partial y} &= -\hat{\rho}(c_1 + d_1) +
\hat{\rho}\mat{0 & e_1^\intercal}\hat{\theta}\\
\frac{\partial \alpha_1}{\partial \eta}\frac{\text{d}\eta}{\text{d}t} &=
\hat{\rho}\left(e_2^\intercal A_0^2\frac{\text{d}\eta}{\text{d}t} +
\left[0 \quad e_2^\intercal A_0\frac{\text{d}\eta}{\text{d}t}
\quad e_2^\intercal
I_2\frac{\text{d}\eta}{\text{d}t}\right]\hat{\theta}\right)\\
\frac{\partial \alpha_1}{\partial y_r} &= \hat{\rho}(c_1 + d_1)\\
\frac{\partial \alpha_1}{\partial \hat{\theta}} &= - \rho\bar{\omega}^\intercal \\
\frac{\partial \alpha_1}{\partial \hat{\rho}} &= -(c_1+d_1)(y-y_r) +
e_2^\intercal A_0^2\eta -\bar{\omega}^\intercal \hat{\theta}
\end{align}

Transcrevemos abaixo a função que computa o Backstepping com observador de ordem completa:

\lstinputlisting[style=myMatlab]{../matlab/backstepping_obs.m} 